<GENERATED-CODE>
I will provide the necessary updates for `src/quickexpense/services/agents/cra_rules_agent.py`.

1.  **Update `cra_rules_agent.py`:** Modify the `_build_refinement_prompt`, `_build_fallback_prompt`, and `_get_rag_context` methods to add logging, improve query construction, and correct the citation format in the prompts.

<UPDATED_EXISTING_FILE: src/quickexpense/services/agents/cra_rules_agent.py>
```python
...
    def _build_refinement_prompt(
        self,
        receipt_data: dict[str, Any],
        best_match: Any,  # noqa: ANN401
        all_matches: list[Any],  # noqa: ARG002
    ) -> str:
        """Build prompt with RAG context for refining categorization."""
        vendor_name = receipt_data.get("vendor_name", "")
        line_items = receipt_data.get("line_items", [])

        # Add tax/tip items from top-level fields before processing
        line_items = self._add_tax_and_tip_items(line_items, receipt_data)

        # GET RAG CONTEXT (NEW)
        line_items_text = " ".join(
            [
                item.get("description", "")
                for item in line_items
                if isinstance(item, dict)
            ]
        )
        rag_context = self._get_rag_context(
            expense_description=line_items_text,
            expense_category=best_match.rule.category,
            vendor_name=vendor_name,
        )

        # Build structured JSON input array (NOT concatenated string)
        line_items_json = json.dumps(
            [
                {
                    "line_number": i + 1,
                    "description": item.get("description", ""),
                    "amount": float(item.get("total_price", 0)),
                }
                for i, item in enumerate(line_items)
                if isinstance(item, dict)
            ]
        )

        return f"""
You are an expert Canadian tax categorization agent for business expenses.

**AUTHORITATIVE CRA CONTEXT:**
---
{rag_context}
---

**CRITICAL INSTRUCTIONS:**
1. You MUST process EACH line item separately - do NOT aggregate or summarize
2. You MUST return valid JSON with a "processed_items" array
3. You MUST only use categories from the ALLOWED_CATEGORIES list below
4. If the CRA context above contains relevant citations, you MUST:
   - Reference them in your reasoning
   - Include the citation IDs in a "citations" field
   - Base your decision on the official CRA guidance
5. If an item's business purpose is ambiguous or possibly personal, use
   "Uncategorized-Review-Required"
6. Apply CRA rules: Meals 50%, Lodging 100%, GST/HST 100%, Office Supplies 100%

**ALLOWED_CATEGORIES:**
{json.dumps(ALLOWED_CATEGORIES, indent=2)}

**REQUIRED OUTPUT SCHEMA:**
{{
  "processed_items": [
    {{
      "line_number": integer,
      "original_description": "string",
      "category": "string (from ALLOWED_CATEGORIES)",
      "deductibility_percent": integer (0-100),
      "reasoning": "Brief explanation with CRA citation reference if available",
      "citations": ["LINE-####", ...]
    }}
  ]
}}

**SUGGESTED CATEGORIZATION (from rules engine):**
- Category: {best_match.rule.category}
- Deductibility: {best_match.rule.deductibility_rate}%
- Confidence: {best_match.confidence_score:.2f}
- Reasoning: {best_match.matching_reason}

**EXPENSE TO PROCESS:**
INPUT:
{{
  "vendor_name": "{vendor_name}",
  "line_items": {line_items_json}
}}

YOUR RESPONSE (valid JSON only):
"""

    def _build_fallback_prompt(self, receipt_data: dict[str, Any]) -> str:
        """Build prompt with RAG context for fallback categorization."""
        vendor_name = receipt_data.get("vendor_name", "")
        line_items = receipt_data.get("line_items", [])

        # Add tax/tip items from top-level fields before processing
        line_items = self._add_tax_and_tip_items(line_items, receipt_data)

        # GET RAG CONTEXT (NEW)
        line_items_text = " ".join(
            [
                item.get("description", "")
                for item in line_items
                if isinstance(item, dict)
            ]
        )
        rag_context = self._get_rag_context(
            expense_description=line_items_text,
            expense_category=None,  # No category hint in fallback
            vendor_name=vendor_name,
        )

        # Build structured JSON input array (NOT concatenated string)
        line_items_json = json.dumps(
            [
                {
                    "line_number": i + 1,
                    "description": item.get("description", ""),
                    "amount": float(item.get("total_price", 0)),
                }
                for i, item in enumerate(line_items)
                if isinstance(item, dict)
            ]
        )

        return f"""
You are an expert Canadian tax categorization agent for business expenses.

**AUTHORITATIVE CRA CONTEXT:**
---
{rag_context}
---

**CRITICAL INSTRUCTIONS:**
1. You MUST process EACH line item separately - do NOT aggregate or summarize
2. You MUST return valid JSON with a "processed_items" array
3. You MUST only use categories from the ALLOWED_CATEGORIES list below
4. If the CRA context above contains relevant citations, you MUST:
   - Reference them in your reasoning
   - Include the citation IDs in a "citations" field
   - Base your decision on the official CRA guidance
5. If an item's business purpose is ambiguous or possibly personal, use
   "Uncategorized-Review-Required"
6. Apply CRA rules: Meals 50%, Lodging 100%, GST/HST 100%, Office Supplies 100%

**ALLOWED_CATEGORIES:**
{json.dumps(ALLOWED_CATEGORIES, indent=2)}

**REQUIRED OUTPUT SCHEMA:**
{{
  "processed_items": [
    {{
      "line_number": integer,
      "original_description": "string",
      "category": "string (from ALLOWED_CATEGORIES)",
      "deductibility_percent": integer (0-100),
      "reasoning": "Brief explanation with CRA citation reference if available",
      "citations": ["LINE-####", ...]
    }}
  ]
}}

**KEY CRA RULES:**
- Meals & Entertainment: 50% deductible (ITA Section 67.1)
- Travel Lodging: 100% deductible
- GST/HST: 100% deductible as Input Tax Credit
- Office Supplies: 100% deductible
- Professional Services: 100% deductible

**EXPENSE TO PROCESS:**
INPUT:
{{
  "vendor_name": "{vendor_name}",
  "line_items": {line_items_json}
}}

YOUR RESPONSE (valid JSON only):
"""

    def _parse_response(
...
context_end_text = """
        return max(0.0, min(base_confidence, 1.0))

    def _get_rag_context(
        self,
        expense_description: str,
        expense_category: str | None = None,
        vendor_name: str | None = None,
    ) -> str:
        """Retrieve and format CRA context from RAG database."""
        # Mapping from application categories to simpler RAG-friendly terms
        RAG_CATEGORY_MAP = {
            "Travel-Lodging": "lodging",
            "Travel-Meals": "meals",
            "Meals & Entertainment": "meals",
            "Fuel-Vehicle": "vehicle expenses",
            "Office-Supplies": "office supplies",
            "Capital-Equipment": "capital equipment",
            "Professional-Services": "professional services",
        }

        try:
            import qe_tax_rag as qe

            # Normalize the expense category for RAG search
            rag_category = (
                RAG_CATEGORY_MAP.get(expense_category) if expense_category else None
            )

            # Build a more focused search query
            query_parts = [expense_description]
            if vendor_name:
                query_parts.append(vendor_name)
            if rag_category:
                query_parts.append(rag_category)
            query_parts.append("business expense tax deduction rules")
            query = " ".join(filter(None, query_parts))

            expense_types_filter = [rag_category] if rag_category else []

            logger.debug(
                "Querying RAG with: query='%s', expense_types=%s",
                query,
                expense_types_filter,
            )

            # Search RAG database
            results = qe.search(
                query=query,
                expense_types=expense_types_filter,
                top_k=3,
            )

            logger.debug("RAG search returned %d results.", len(results) if results else 0)
            if results:
                # Log raw results for deep debugging if needed
                try:
                    raw_results_str = json.dumps(
                        [r.to_dict() for r in results], indent=2
                    )
                    logger.debug("Raw RAG results:\n%s", raw_results_str)
                except Exception:
                    logger.debug("Could not serialize raw RAG results.")

            if not results:
                return "No specific CRA documents found. Rely on general tax knowledge."

            # Format results
            context_parts = ["Relevant CRA Documents Found:"]
            for i, result in enumerate(results, 1):
                # Escape quotes to prevent JSON issues
                content = result.content[:400].replace('"', '\\"')
                entry = (
                    f"\\n{i}. Citation ID: {result.citation_id}\\n"
                    f"   Source: {result.source_url}\\n"
                    f'   Content: "{content}..."'
                )
                context_parts.append(entry)

            final_context = "\\n".join(context_parts)
            logger.debug("Formatted RAG context:\n%s", final_context)
            return final_context

        except ImportError:
            logger.error("`qe_tax_rag` package not found. RAG search is disabled.")
            return "RAG system not available. Rely on general tax knowledge."
        except Exception as e:
            logger.warning("RAG search failed with %s: %s", type(e).__name__, e)
            return "RAG search failed. Rely on general tax knowledge."

    def _get_cra_system_message(self) -> str:
        """Get the system message for the CRA rules agent."""
...
"""
```
</UPDATED_EXISTING_FILE>
</GENERATED-CODE>
